#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "common.h"


layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE) in;

layout(rgba8, binding = 0) uniform restrict readonly image2D inputImage;
layout(rgba8, binding = 1) uniform restrict writeonly image2D outputImage;

layout(std140, binding = 2) uniform GaussUBO_t
{
    float coeffs[KERNEL_SIZE];
} ubo;


shared vec4 shared_pixels[SHARED_WINDOW_SIZE][SHARED_WINDOW_SIZE];


void main()
{
    ivec2 image_size = imageSize(inputImage);
	ivec2 global_coord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 local_coord = ivec2(gl_LocalInvocationID.xy);

	// caching
	for (int i = 0; i < KERNEL_SIZE; i++)
	{
		for (int j = 0; j < KERNEL_SIZE; j++)
		{
			ivec2 cache_coords = local_coord + ivec2(i, j);
			ivec2 image_coords = global_coord - ivec2(HALF_SIZE, HALF_SIZE) + ivec2(i, j);

			image_coords = clamp(image_coords, ivec2(0, 0), image_size);

			shared_pixels[cache_coords.x][cache_coords.y] = imageLoad(inputImage, image_coords); 
		}
	}

	barrier();

	// apply gaussian kernel
	
	vec4[KERNEL_SIZE] horizontal_pass_results;

	// vertical pass (y convolution)
	for (int i = 0; i < KERNEL_SIZE; i++)
	{
		vec4 result_color = vec4(0.0f);
		for (int j = 0; j < KERNEL_SIZE; j++)
		{
			ivec2 cache_coords = local_coord + ivec2(i, j);
			result_color += shared_pixels[cache_coords.x][cache_coords.y] * ubo.coeffs[i];
		}
		horizontal_pass_results[i] = vec4(result_color.rgb, 1.0f);
	}

	barrier();

	// horizontal pass (x convolution)
	vec4 result_color = vec4(0.0f);
	for (int i = 0; i < KERNEL_SIZE; i++)
	{
		result_color += horizontal_pass_results[i] * ubo.coeffs[i];
	}

	barrier();

	imageStore(outputImage, global_coord, vec4(result_color.rgb, 1.0f));
	

	// passthrough output
	// ivec2 cache_center_coords = local_coord + ivec2(HALF_SIZE, HALF_SIZE);
	// imageStore(outputImage, global_coord, shared_pixels[cache_center_coords.x][cache_center_coords.y]);
}